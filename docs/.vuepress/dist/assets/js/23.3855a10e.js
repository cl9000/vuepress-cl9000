(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{373:function(e,a,t){"use strict";t.r(a);var l=t(42),_=Object(l.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"消息传递的方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息传递的方式"}},[e._v("#")]),e._v(" 消息传递的方式")]),e._v(" "),t("h2",{attrs:{id:"_1-kvc实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-kvc实现原理"}},[e._v("#")]),e._v(" 1.KVC实现原理")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("KVC，键-值编码，使用字符串直接访问对象的属性。")])]),e._v(" "),t("li",[t("p",[e._v("底层实现，当一个对象调用setValue方法时，方法内部会做以下操作：")]),e._v(" "),t("p",[e._v("1.检查是否存在相应key的set方法，如果存在，就调用set方法")]),e._v(" "),t("p",[e._v("2.如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值")]),e._v(" "),t("p",[e._v("3.如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值")]),e._v(" "),t("p",[e._v("4.如果还没找到，则调用valueForUndefinedKey：和setValue：forUndefinedKey：方法")])])]),e._v(" "),t("h2",{attrs:{id:"_2-kvo的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-kvo的实现原理"}},[e._v("#")]),e._v(" 2.KVO的实现原理")]),e._v(" "),t("p",[t("img",{attrs:{src:"/iOS/kvo.png",alt:"KVO"}})]),e._v(" "),t("p",[e._v("KVO-键值观察机制，原理如下：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("1.当给A类添加KVO的时候，runtime动态的生成了一个子类NSKVONotifying_A，让A类的isa指针指向NSKVONotifying_A类，重写class方法，隐藏对象真实类信息")])]),e._v(" "),t("li",[t("p",[e._v("2.重写监听属性的setter方法，在setter方法内部调用了Foundation 的 _NSSetObjectValueAndNotify 函数")])]),e._v(" "),t("li",[t("p",[e._v("3._NSSetObjectValueAndNotify函数内部")]),e._v(" "),t("p",[e._v("a) 首先会调用 willChangeValueForKey")]),e._v(" "),t("p",[e._v("b) 然后给属性赋值")]),e._v(" "),t("p",[e._v("c) 最后调用 didChangeValueForKey")]),e._v(" "),t("p",[e._v("d) 最后调用 observer 的 observeValueForKeyPath 去告诉监听器属性值发生了改变 .")])]),e._v(" "),t("li",[t("p",[e._v("4.重写了dealloc做一些 KVO 内存释放")])])]),e._v(" "),t("h2",{attrs:{id:"_3-如何手动触发kvo方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何手动触发kvo方法"}},[e._v("#")]),e._v(" 3.如何手动触发KVO方法")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("手动调用willChangeValueForKey和didChangeValueForKey方法")])]),e._v(" "),t("li",[t("p",[e._v("键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangeValueForKey。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， didChangeValueForKey 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了\n有人可能会问只调用didChangeValueForKey方法可以触发KVO方法，其实是不能的，因为willChangeValueForKey: 记录旧的值，如果不记录旧的值，那就没有改变一说了")])])]),e._v(" "),t("h2",{attrs:{id:"_4-通知和代理有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-通知和代理有什么区别"}},[e._v("#")]),e._v(" 4.通知和代理有什么区别")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("通知是观察者模式，适合一对多的场景")])]),e._v(" "),t("li",[t("p",[e._v("代理模式适合一对一的反向传值")])]),e._v(" "),t("li",[t("p",[e._v("通知耦合度低，代理的耦合度高")])])]),e._v(" "),t("h2",{attrs:{id:"_5-block和delegate的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-block和delegate的区别"}},[e._v("#")]),e._v(" 5.block和delegate的区别")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("delegate运行成本低，block的运行成本高")]),e._v(" "),t("p",[e._v("block出栈需要将使用的数据从栈内存拷贝到堆内存，当然对象的话就是加计数，使用完或者block置nil后才消除。delegate只是保存了一个对象指针，直接回调，没有额外消耗。就像C的函数指针，只多做了一个查表动作。")])]),e._v(" "),t("li",[t("p",[e._v("delegate更适用于多个回调方法（3个以上），block则适用于1，2个回调时。")])])]),e._v(" "),t("h2",{attrs:{id:"_6-为什么block用copy关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-为什么block用copy关键字"}},[e._v("#")]),e._v(" 6.为什么Block用copy关键字")]),e._v(" "),t("p",[e._v("Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。")])])}),[],!1,null,null,null);a.default=_.exports}}]);