(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{361:function(t,s,a){"use strict";a.r(s);var n=a(42),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"runloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[t._v("#")]),t._v(" Runloop")]),t._v(" "),a("h2",{attrs:{id:"_1-runloop-和线程的关系？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-runloop-和线程的关系？"}},[t._v("#")]),t._v(" 1.Runloop 和线程的关系？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("一个线程对应一个 Runloop。")])]),t._v(" "),a("li",[a("p",[t._v("主线程的默认就有了 Runloop。")])]),t._v(" "),a("li",[a("p",[t._v("子线程的 Runloop 以懒加载的形式创建。")])]),t._v(" "),a("li",[a("p",[t._v("Runloop 存储在一个全局的可变字典里，线程是 key ，Runloop 是 value。")])])]),t._v(" "),a("h2",{attrs:{id:"_2-runloop的运行模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-runloop的运行模式"}},[t._v("#")]),t._v(" 2.RunLoop的运行模式")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("RunLoop的运行模式共有5种，RunLoop只会运行在一个模式下，要切换模式，就要暂停当前模式，重写启动一个运行模式")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" kCFRunLoopDefaultMode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" App的默认运行模式，通常主线程是在这个运行模式下运行\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" UITrackingRunLoopMode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" kCFRunLoopCommonModes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 伪模式，不是一种真正的运行模式\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" UIInitializationRunLoopMode：在刚启动App时第进入的第一个Mode，启动完成后就不再使用\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])])])]),t._v(" "),a("h2",{attrs:{id:"_3-runloop内部逻辑？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-runloop内部逻辑？"}},[t._v("#")]),t._v(" 3.runloop内部逻辑？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/iOS/runloop.png",alt:"RunLoop"}})])]),t._v(" "),a("li",[a("p",[t._v("内部逻辑：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("通知 Observer 已经进入了 RunLoop")])]),t._v(" "),a("li",[a("p",[t._v("通知 Observer 即将处理 Timer")])]),t._v(" "),a("li",[a("p",[t._v("通知 Observer 即将处理非基于端口的输入源（即将处理 Source0）")])]),t._v(" "),a("li",[a("p",[t._v("处理那些准备好的非基于端口的输入源（处理 Source0）")])]),t._v(" "),a("li",[a("p",[t._v("如果基于端口的输入源准备就绪并等待处理，请立刻处理该事件。转到第 9 步（处理 Source1）")])]),t._v(" "),a("li",[a("p",[t._v("通知 Observer 线程即将休眠")])]),t._v(" "),a("li",[a("p",[t._v("将线程置于休眠状态，直到发生以下事件之一")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("事件到达基于端口的输入源（port-based input sources）(也就是 Source0)")])]),t._v(" "),a("li",[a("p",[t._v("Timer 到时间执行")])]),t._v(" "),a("li",[a("p",[t._v("外部手动唤醒")])]),t._v(" "),a("li",[a("p",[t._v("为 RunLoop 设定的时间超时")])])])]),t._v(" "),a("li",[a("p",[t._v("通知 Observer 线程刚被唤醒（还没处理事件）")])]),t._v(" "),a("li",[a("p",[t._v("处理待处理事件")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("如果是 Timer 事件，处理 Timer 并重新启动循环，跳到第 2 步")])]),t._v(" "),a("li",[a("p",[t._v("如果输入源被触发，处理该事件（文档上是 deliver the event）")])]),t._v(" "),a("li",[a("p",[t._v("如果 RunLoop 被手动唤醒但尚未超时，重新启动循环，跳到第 2 步")])])])])])])]),t._v(" "),a("h2",{attrs:{id:"_4-autoreleasepool-在何时被释放？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-autoreleasepool-在何时被释放？"}},[t._v("#")]),t._v(" 4.autoreleasePool 在何时被释放？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。")])]),t._v(" "),a("li",[a("p",[t._v("第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。")])]),t._v(" "),a("li",[a("p",[t._v("第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。")])]),t._v(" "),a("li",[a("p",[t._v("在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。")])])]),t._v(" "),a("h2",{attrs:{id:"_5-gcd-在runloop中的使用？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-gcd-在runloop中的使用？"}},[t._v("#")]),t._v(" 5.GCD 在Runloop中的使用？")]),t._v(" "),a("ul",[a("li",[t._v("GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。")])]),t._v(" "),a("h2",{attrs:{id:"_6-afnetworking-中如何运用-runloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-afnetworking-中如何运用-runloop"}},[t._v("#")]),t._v(" 6.AFNetworking 中如何运用 Runloop?")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("networkRequestThreadEntryPoint"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("__unused object "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    @autoreleasepool "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSThread currentThread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" setName"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("@"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"AFNetworking"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        NSRunLoop "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("runLoop "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSRunLoop currentRunLoop"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("runLoop addPort"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSMachPort port"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" forMode"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("NSDefaultRunLoopMode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("runLoop run"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSThread "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("networkRequestThread "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" NSThread "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("_networkRequestThread "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nil"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" dispatch_once_t oncePredicate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_once")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("oncePredicate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        _networkRequestThread "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSThread alloc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" initWithTarget"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("self selector"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("networkRequestThreadEntryPoint"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" object"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("_networkRequestThread start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" _networkRequestThread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("start "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lock lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self isCancelled"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self performSelector"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cancelConnection"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" onThread"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self class"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" networkRequestThread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" withObject"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("nil waitUntilDone"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("NO modes"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("runLoopModes allObjects"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self isReady"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" AFOperationExecutingState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self performSelector"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("operationDidStart"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" onThread"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self class"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" networkRequestThread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" withObject"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("nil waitUntilDone"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("NO modes"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("runLoopModes allObjects"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lock unlock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。")])])]),t._v(" "),a("h2",{attrs:{id:"_7-performselector-的实现原理？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-performselector-的实现原理？"}},[t._v("#")]),t._v(" 7.PerformSelector 的实现原理？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。")])]),t._v(" "),a("li",[a("p",[t._v("当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。")])])]),t._v(" "),a("h2",{attrs:{id:"_8-performselector-afterdelay-这个方法在子线程中是否起作用？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-performselector-afterdelay-这个方法在子线程中是否起作用？"}},[t._v("#")]),t._v(" 8.PerformSelector:afterDelay:这个方法在子线程中是否起作用？")]),t._v(" "),a("ul",[a("li",[t._v("不起作用，子线程默认没有 Runloop，也就没有 Timer。可以使用 GCD的dispatch_after来实现")])]),t._v(" "),a("h2",{attrs:{id:"_9-事件响应的过程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-事件响应的过程？"}},[t._v("#")]),t._v(" 9.事件响应的过程？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。")])]),t._v(" "),a("li",[a("p",[t._v("当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。")])]),t._v(" "),a("li",[a("p",[t._v("_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。")])])]),t._v(" "),a("h2",{attrs:{id:"_10-手势识别的过程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-手势识别的过程？"}},[t._v("#")]),t._v(" 10.手势识别的过程？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。")])]),t._v(" "),a("li",[a("p",[t._v("苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。")])]),t._v(" "),a("li",[a("p",[t._v("当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。")])])]),t._v(" "),a("h2",{attrs:{id:"_11-cadispalytimer和timer哪个更精确"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-cadispalytimer和timer哪个更精确"}},[t._v("#")]),t._v(" 11.CADispalyTimer和Timer哪个更精确")]),t._v(" "),a("p",[t._v("CADisplayLink 更精确")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。")])]),t._v(" "),a("li",[a("p",[t._v("NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。")])]),t._v(" "),a("li",[a("p",[t._v("CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);